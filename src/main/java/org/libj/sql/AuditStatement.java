/* Copyright (c) 2009 LibJ
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * You should have received a copy of The MIT License (MIT) along with this
 * program. If not, see <http://opensource.org/licenses/MIT/>.
 */

package org.libj.sql;

import static org.libj.sql.AuditUtil.*;

import java.sql.ResultSet;
import java.sql.SQLException;
import java.sql.Statement;
import java.util.ArrayList;

import org.libj.lang.Strings;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

/**
 * A {@link Statement} that delegates all method calls to another statement. This class overrides all execution methods in order to
 * log the SQL that is executed. When an "execute" method is invoked, it will be logged to the logger associated with the
 * {@link AuditStatement} class.
 */
public class AuditStatement extends Audit implements DelegateStatement {
  private static final Logger logger = LoggerFactory.getLogger(AuditStatement.class);

  /**
   * Releases the specified {@link Statement} object's database and JDBC resources immediately instead of waiting for them to be
   * automatically released.
   * <p>
   * This method differs itself from {@link Statement#close()} by not throwing a {@link SQLException} if a database access error
   * occurs. If a database access error occurs, a warning will be logged to the logger associated with the {@link AuditStatement}
   * class.
   *
   * @param statement The {@link Statement} to close.
   * @return {@code null} if the {@link ResultSet#close()} operation is successful, otherwise the {@link SQLException} that caused the
   *         failure.
   * @throws NullPointerException If {@code statement} is null.
   */
  public static SQLException close(final Statement statement) {
    try {
      if (!statement.isClosed())
        statement.close();

      return null;
    }
    catch (final SQLException e) {
      if (logger.isWarnEnabled()) { logger.warn(statement.getClass().getName() + ".close(): " + e.getMessage()); }
      return e;
    }
  }

  /**
   * Returns a {@link AuditStatement} if {@code DEBUG} level logging is enabled. Otherwise, returns the provided target
   * {@link Statement}.
   *
   * @param target The {@link Statement} to wrap.
   * @return A {@link AuditStatement} if {@code DEBUG} level logging is enabled. Otherwise, returns the provided target
   *         {@link Statement}.
   */
  public static Statement wrapIfDebugEnabled(final Statement target) {
    return logger.isDebugEnabled() ? new AuditStatement(target) : target;
  }

  private final Statement target;
  private ArrayList<String> batchLogs;

  /**
   * Creates a new {@link AuditStatement} with the specified {@code target} to which all method calls will be delegated.
   *
   * @param target The {@link Statement} to which all method calls will be delegated.
   */
  public AuditStatement(final Statement target) {
    this.target = target;
  }

  @Override
  protected Logger logger() {
    return logger;
  }

  protected long getLogTimestamp(final boolean enabled) {
    return enabled ? System.currentTimeMillis() : -1;
  }

  protected int getLogResultSetSize(final boolean enabled, final ResultSet resultSet) throws SQLException {
    return enabled ? ResultSets.getSize(resultSet) : -1;
  }

  /**
   * Returns a log entry for the provided parameters.
   *
   * @param enabled If {@code true}, this method will return a log entry for the provided parameters. Otherwise if {@code false}, this
   *          method will return {@code null}.
   * @param method The name of the method for which the log entry is being created.
   * @param sql The SQL statement.
   * @param autoGeneratedKeys A flag indicating whether auto-generated keys should be returned; one of
   *          {@link Statement#RETURN_GENERATED_KEYS}, {@link Statement#NO_GENERATED_KEYS}, or {@code Integer.MIN_VALUE} for the
   *          parameter to be omitted.
   * @param columnIndexes An array of column indexes indicating the columns that should be returned from the inserted row or rows, or
   *          {@code null} for the parameter to be omitted.
   * @param columnNames An array of column names indicating the columns that should be returned from the inserted row or rows, or
   *          {@code null} for the parameter to be omitted.
   * @param result An object representing the result value from the caller's context.
   * @param time The timestamp before the invocation of the method to be timed.
   * @return A log entry for the provided parameters.
   * @throws SQLException If an I/O exception has occurred.
   */
  protected String log(final boolean enabled, final String method, final String sql, final int autoGeneratedKeys, final int[] columnIndexes, final String[] columnNames, final Object result, final long time) throws SQLException {
    if (!enabled)
      return null;

    final StringBuilder b = AuditUtil.log(this, method, getConnection(), sql);
    if (autoGeneratedKeys != Integer.MIN_VALUE) {
      b.append(", ").append(autoGeneratedKeys);
    }
    else if (columnIndexes != null) {
      for (final int columnIndex : columnIndexes) // [A]
        b.append(", ").append(columnIndex);
    }
    else if (columnNames != null) {
      for (final String columnName : columnNames) // [A]
        b.append(", ").append(columnName);
    }

    b.append("\n)");

    if (result != null)
      withResult(b, result, time);

    return b.toString();
  }

  /**
   * Returns a log entry for the provided parameters for the context of {@link #executeBatch()}.
   *
   * @param count An array of {@code int} values representing the row counts for execution in the batch.
   * @param time The timestamp before the invocation of the method to be timed.
   * @return A log entry for the provided parameters for the context of {@link #executeBatch()}.
   * @throws SQLException If an I/O error has occurred.
   */
  protected String logExecuteBatch(final int[] count, final long time) throws SQLException {
    final StringBuilder b = AuditUtil.log(this, "executeBatch", getConnection(), "[");
    if (batchLogs != null) {
      if (count != null)
        for (int i = 0, i$ = batchLogs.size(); i < i$; ++i) // [RA]
          b.append("\n ").append(Strings.indent(batchLogs.get(i), 2)).append(" -> ").append(count[i]);
      else
        for (int i = 0, i$ = batchLogs.size(); i < i$; ++i) // [RA]
          b.append("\n ").append(Strings.indent(batchLogs.get(i), 2)).append(" -> -1");
    }

    b.append("\n])");
    if (count != null)
      b.append(' ').append(System.currentTimeMillis() - time).append("ms");

    return b.toString();
  }

  @Override
  public Statement getTarget() {
    return target;
  }

  @Override
  public ResultSet executeQuery(final String sql) throws SQLException {
    long time = -1;
    int size = -1;
    final boolean isDebugEnabled = isDebugEnabled();
    try {
      trace(StatementType.QUERY, log(isTraceEnabled(), "executeQuery", sql, Integer.MIN_VALUE, null, null, null, -1));
      time = getLogTimestamp(isDebugEnabled);
      final ResultSet resultSet = getTarget().executeQuery(sql);
      size = getLogResultSetSize(isDebugEnabled, resultSet);
      return resultSet;
    }
    finally {
      debug(StatementType.QUERY, log(isDebugEnabled, "executeQuery", sql, Integer.MIN_VALUE, null, null, size, time));
    }
  }

  @Override
  public int executeUpdate(final String sql) throws SQLException {
    long time = -1;
    int count = -1;
    final boolean isDebugEnabled = isDebugEnabled();
    try {
      trace(StatementType.UPDATE, log(isTraceEnabled(), "executeUpdate", sql, Integer.MIN_VALUE, null, null, null, -1));
      time = getLogTimestamp(isDebugEnabled);
      return count = getTarget().executeUpdate(sql);
    }
    finally {
      debug(StatementType.UPDATE, log(isDebugEnabled, "executeUpdate", sql, Integer.MIN_VALUE, null, null, count, time));
    }
  }

  @Override
  public void close() throws SQLException {
    try {
      final Statement target = getTarget();
      if (!target.isClosed())
        target.close();

      if (batchLogs != null) {
        batchLogs.clear();
        batchLogs = null;
      }
    }
    catch (final SQLException e) {
      if (!"Connection is closed.".equals(e.getMessage()))
        throw e;
    }
  }

  @Override
  public boolean execute(final String sql) throws SQLException {
    long time = -1;
    Boolean result = null;
    final boolean isDebugEnabled = isDebugEnabled();
    try {
      trace(StatementType.MULTIPLE, log(isTraceEnabled(), "execute", sql, Integer.MIN_VALUE, null, null, null, -1));
      time = getLogTimestamp(isDebugEnabled);
      return result = getTarget().execute(sql);
    }
    finally {
      debug(StatementType.MULTIPLE, log(isDebugEnabled, "execute", sql, Integer.MIN_VALUE, null, null, result, time));
    }
  }

  /**
   * Adds the provided {@code sql} to the list of statements executed as a batch by this instance, for the purpose of logging.
   *
   * @param enabled Whether the addition of parameter is enabled.
   * @param sql The SQL to add.
   */
  protected void logAddBatch(final boolean enabled, final String sql) {
    if (!enabled)
      return;

    if (batchLogs == null)
      batchLogs = new ArrayList<>();

    batchLogs.add(sql);
  }

  @Override
  public void addBatch(final String sql) throws SQLException {
    logAddBatch(isDebugEnabled(), sql);
    getTarget().addBatch(sql);
  }

  @Override
  public void clearBatch() throws SQLException {
    getTarget().clearBatch();
    if (batchLogs != null)
      batchLogs.clear();
  }

  @Override
  public int[] executeBatch() throws SQLException {
    long time = -1;
    int[] count = null;
    final boolean isDebugEnabled = isDebugEnabled();
    try {
      trace(StatementType.MULTIPLE, log(isTraceEnabled(), "executeBatch", logExecuteBatch(null, -1), Integer.MIN_VALUE, null, null, null, -1));
      time = getLogTimestamp(isDebugEnabled);
      return count = getTarget().executeBatch();
    }
    finally {
      debug(StatementType.MULTIPLE, log(isDebugEnabled, "executeBatch", logExecuteBatch(count, time), Integer.MIN_VALUE, null, null, null, -1));
    }
  }

  @Override
  public int executeUpdate(final String sql, final int autoGeneratedKeys) throws SQLException {
    long time = -1;
    int count = -1;
    final boolean isDebugEnabled = isDebugEnabled();
    try {
      trace(StatementType.UPDATE, log(isTraceEnabled(), "executeUpdate", sql, autoGeneratedKeys, null, null, null, -1));
      time = getLogTimestamp(isDebugEnabled);
      return count = getTarget().executeUpdate(sql, autoGeneratedKeys);
    }
    finally {
      debug(StatementType.UPDATE, log(isDebugEnabled, "executeUpdate", sql, autoGeneratedKeys, null, null, count, time));
    }
  }

  @Override
  public int executeUpdate(final String sql, final int[] columnIndexes) throws SQLException {
    long time = -1;
    int count = -1;
    final boolean isDebugEnabled = isDebugEnabled();
    try {
      trace(StatementType.UPDATE, log(isTraceEnabled(), "executeUpdate", sql, Integer.MIN_VALUE, columnIndexes, null, null, -1));
      time = getLogTimestamp(isDebugEnabled);
      return count = getTarget().executeUpdate(sql, columnIndexes);
    }
    finally {
      debug(StatementType.UPDATE, log(isDebugEnabled, "executeUpdate", sql, Integer.MIN_VALUE, columnIndexes, null, count, time));
    }
  }

  @Override
  public int executeUpdate(final String sql, final String[] columnNames) throws SQLException {
    long time = -1;
    int count = -1;
    final boolean isDebugEnabled = isDebugEnabled();
    try {
      trace(StatementType.UPDATE, log(isTraceEnabled(), "executeUpdate", sql, Integer.MIN_VALUE, null, columnNames, null, -1));
      time = getLogTimestamp(isDebugEnabled);
      return count = getTarget().executeUpdate(sql, columnNames);
    }
    finally {
      debug(StatementType.UPDATE, log(isDebugEnabled, "executeUpdate", sql, Integer.MIN_VALUE, null, columnNames, count, time));
    }
  }

  @Override
  public boolean execute(final String sql, final int autoGeneratedKeys) throws SQLException {
    long time = -1;
    Boolean result = null;
    final boolean isDebugEnabled = isDebugEnabled();
    try {
      trace(StatementType.MULTIPLE, log(isTraceEnabled(), "execute", sql, autoGeneratedKeys, null, null, null, -1));
      time = getLogTimestamp(isDebugEnabled);
      return result = getTarget().execute(sql, autoGeneratedKeys);
    }
    finally {
      debug(StatementType.MULTIPLE, log(isDebugEnabled, "execute", sql, autoGeneratedKeys, null, null, result, time));
    }
  }

  @Override
  public boolean execute(final String sql, final int[] columnIndexes) throws SQLException {
    long time = -1;
    Boolean result = null;
    final boolean isDebugEnabled = isDebugEnabled();
    try {
      trace(StatementType.MULTIPLE, log(isTraceEnabled(), "execute", sql, Integer.MIN_VALUE, columnIndexes, null, null, -1));
      time = getLogTimestamp(isDebugEnabled);
      return result = getTarget().execute(sql, columnIndexes);
    }
    finally {
      debug(StatementType.MULTIPLE, log(isDebugEnabled, "execute", sql, Integer.MIN_VALUE, columnIndexes, null, result, time));
    }
  }

  @Override
  public boolean execute(final String sql, final String[] columnNames) throws SQLException {
    long time = -1;
    Boolean result = null;
    final boolean isDebugEnabled = isDebugEnabled();
    try {
      trace(StatementType.MULTIPLE, log(isTraceEnabled(), "execute", sql, Integer.MIN_VALUE, null, columnNames, null, -1));
      time = getLogTimestamp(isDebugEnabled);
      return result = getTarget().execute(sql, columnNames);
    }
    finally {
      debug(StatementType.MULTIPLE, log(isDebugEnabled, "execute", sql, Integer.MIN_VALUE, null, columnNames, result, time));
    }
  }

  @Override
  public boolean equals(final Object obj) {
    return getTarget().equals(obj);
  }

  @Override
  public int hashCode() {
    return getTarget().hashCode();
  }

  @Override
  public String toString() {
    if (batchLogs == null)
      return getTarget().toString();

    final StringBuilder b = new StringBuilder();
    for (int i = 0, i$ = batchLogs.size(); i < i$; ++i) { // [RA]
      if (i > 0)
        b.append('\n');

      b.append(batchLogs.get(i));
    }

    return b.toString();
  }
}